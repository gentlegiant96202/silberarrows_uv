"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/inventory/page",{

/***/ "(app-pages-browser)/./components/modules/uv-crm/components/MediaUploader.tsx":
/*!****************************************************************!*\
  !*** ./components/modules/uv-crm/components/MediaUploader.tsx ***!
  \****************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ MediaUploader)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @/lib/supabaseClient */ \"(app-pages-browser)/./lib/supabaseClient.ts\");\n\nvar _s = $RefreshSig$();\n\n\n// Function to convert image to specific ratio while maintaining transparency\nconst processImageToRatio = async function(file, targetWidth, targetHeight) {\n    let addBackground = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;\n    return new Promise((resolve)=>{\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.onload = ()=>{\n            canvas.width = targetWidth;\n            canvas.height = targetHeight;\n            if (!ctx) {\n                resolve(file); // fallback to original if canvas context fails\n                return;\n            }\n            // Add background only if requested (for main version)\n            if (addBackground) {\n                // Create light grey gradient background\n                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);\n                gradient.addColorStop(0, '#f8f8f8'); // Very light grey at top\n                gradient.addColorStop(0.5, '#e8e8e8'); // Light grey in middle\n                gradient.addColorStop(1, '#d8d8d8'); // Medium light grey at bottom\n                // Fill background with gradient\n                ctx.fillStyle = gradient;\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n            }\n            // Calculate scaling to fill entire canvas while maintaining aspect ratio (cover mode)\n            const imgAspectRatio = img.width / img.height;\n            const canvasAspectRatio = targetWidth / targetHeight;\n            let drawWidth, drawHeight, offsetX, offsetY;\n            if (imgAspectRatio > canvasAspectRatio) {\n                // Image is wider - fit to height and crop sides\n                drawHeight = targetHeight;\n                drawWidth = targetHeight * imgAspectRatio;\n                offsetX = (targetWidth - drawWidth) / 2;\n                offsetY = 0;\n            } else {\n                // Image is taller - fit to width and crop top/bottom\n                drawWidth = targetWidth;\n                drawHeight = targetWidth / imgAspectRatio;\n                offsetX = 0;\n                offsetY = (targetHeight - drawHeight) / 2;\n            }\n            // Draw the image centered on the canvas\n            ctx.drawImage(img, offsetX, offsetY, drawWidth, drawHeight);\n            // Convert canvas to file\n            canvas.toBlob((blob)=>{\n                if (blob) {\n                    const suffix = addBackground ? '_with_bg' : targetWidth === targetHeight ? '_square' : '_4x5';\n                    const newFile = new File([\n                        blob\n                    ], file.name.replace(/\\.png$/i, \"\".concat(suffix, \".png\")), {\n                        type: 'image/png',\n                        lastModified: Date.now()\n                    });\n                    resolve(newFile);\n                } else {\n                    resolve(file); // fallback to original\n                }\n            }, 'image/png', 0.95);\n        };\n        img.onerror = ()=>{\n            resolve(file); // fallback to original if image loading fails\n        };\n        img.src = URL.createObjectURL(file);\n    });\n};\n// Function to check if PNG has transparency\nconst hasPngTransparency = async (file)=>{\n    if (!file.type.includes('png')) {\n        console.log(\"File \".concat(file.name, \" is not PNG, skipping transparency check\"));\n        return false;\n    }\n    return new Promise((resolve)=>{\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        const img = new Image();\n        img.onload = ()=>{\n            canvas.width = img.width;\n            canvas.height = img.height;\n            if (!ctx) {\n                console.log(\"Failed to get canvas context for \".concat(file.name));\n                resolve(false);\n                return;\n            }\n            ctx.drawImage(img, 0, 0);\n            try {\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                const data = imageData.data;\n                let transparentPixels = 0;\n                let totalPixels = data.length / 4;\n                // Check for any pixels with alpha < 255 (transparency)\n                for(let i = 3; i < data.length; i += 4){\n                    if (data[i] < 255) {\n                        transparentPixels++;\n                    }\n                }\n                const hasTransparency = transparentPixels > 0;\n                console.log(\"Transparency analysis for \".concat(file.name, \": \").concat(transparentPixels, \"/\").concat(totalPixels, \" transparent pixels, result: \").concat(hasTransparency));\n                resolve(hasTransparency);\n            } catch (error) {\n                console.log(\"Error checking transparency for \".concat(file.name, \":\"), error);\n                // If we can't access image data (CORS, etc.), assume it has transparency to be safe\n                console.log(\"Assuming transparency for \".concat(file.name, \" due to access error\"));\n                resolve(true);\n            }\n        };\n        img.onerror = (error)=>{\n            console.log(\"Error loading image \".concat(file.name, \" for transparency check:\"), error);\n            resolve(false);\n        };\n        img.src = URL.createObjectURL(file);\n    });\n};\nfunction MediaUploader(param) {\n    let { carId, onUploaded } = param;\n    _s();\n    const [uploading, setUploading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [progress, setProgress] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [totalFiles, setTotalFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [failedFiles, setFailedFiles] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [retrying, setRetrying] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const handleFiles = async (e)=>{\n        const files = Array.from(e.target.files || []);\n        if (!files.length) return;\n        setUploading(true);\n        setTotalFiles(files.length);\n        setProgress(0);\n        setFailedFiles([]);\n        let failed = [];\n        for(let idx = 0; idx < files.length; idx++){\n            const file = files[idx];\n            if (file.type.startsWith('image')) {\n                try {\n                    // Check if PNG has transparency and process accordingly\n                    if (file.type.includes('png')) {\n                        console.log(\"PNG file detected: \".concat(file.name, \", checking transparency...\"));\n                        const hasTransparency = await hasPngTransparency(file);\n                        console.log(\"Transparency check result for \".concat(file.name, \": \").concat(hasTransparency));\n                        if (hasTransparency) {\n                            console.log(\"Processing transparent PNG: \".concat(file.name, \" into 3 versions\"));\n                            // Create 3 versions for transparent PNGs - all with grey background\n                            const versions = [\n                                {\n                                    file: await processImageToRatio(file, 1600, 1200, true),\n                                    kind: 'photo',\n                                    name: 'Main (with background)',\n                                    metadata: 'main'\n                                },\n                                {\n                                    file: await processImageToRatio(file, 1080, 1350, true),\n                                    kind: 'photo',\n                                    name: '4:5 Ratio (with background)',\n                                    metadata: '4x5'\n                                },\n                                {\n                                    file: await processImageToRatio(file, 1080, 1080, true),\n                                    kind: 'photo',\n                                    name: 'Square (with background)',\n                                    metadata: 'square'\n                                }\n                            ];\n                            console.log(\"Created \".concat(versions.length, \" versions for \").concat(file.name));\n                            // Upload all 3 versions\n                            for (const version of versions){\n                                console.log(\"Uploading \".concat(version.name, \" as \").concat(version.kind, \" with metadata: \").concat(version.metadata));\n                                await uploadSingleVersion(version.file, version.kind, file, idx, failed, version.metadata);\n                            }\n                        } else {\n                            console.log(\"Non-transparent PNG: \".concat(file.name, \", uploading original only\"));\n                            // Non-transparent PNG - just upload original\n                            await uploadSingleVersion(file, 'photo', file, idx, failed);\n                        }\n                    } else {\n                        console.log(\"Non-PNG image: \".concat(file.name, \", uploading original only\"));\n                        // Non-PNG image - just upload original\n                        await uploadSingleVersion(file, 'photo', file, idx, failed);\n                    }\n                } catch (err) {\n                    console.warn('Image processing failed, uploading original', err);\n                    await uploadSingleVersion(file, 'photo', file, idx, failed);\n                }\n            } else {\n                // Non-image file (video, etc.)\n                await uploadSingleVersion(file, file.type.startsWith('video') ? 'video' : 'document', file, idx, failed);\n            }\n            setProgress(Math.round((idx + 1) / files.length * 100));\n        }\n        setProgress(100);\n        setTimeout(()=>{\n            setUploading(false);\n            setProgress(0);\n            setTotalFiles(0);\n            if (onUploaded) onUploaded();\n        }, 800);\n        e.target.value = '';\n    };\n    // Helper function to upload a single version\n    const uploadSingleVersion = async (uploadFile, kind, originalFile, idx, failedArray, metadata)=>{\n        console.log(\"Starting upload: kind=\".concat(kind, \", originalFile=\").concat(originalFile.name, \", uploadFile size=\").concat(uploadFile.size, \", metadata=\").concat(metadata || 'none'));\n        const ext = originalFile.name.split('.').pop();\n        const baseFileName = originalFile.name.replace(/\\.[^/.]+$/, \"\"); // Remove extension\n        const metadataPrefix = metadata ? \"\".concat(metadata, \"-\") : '';\n        const path = \"\".concat(carId, \"/\").concat(metadataPrefix).concat(crypto.randomUUID(), \".\").concat(ext);\n        // Check if car already has media\n        const { count: photoCount } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from('car_media').select('*', {\n            head: true,\n            count: 'exact'\n        }).eq('car_id', carId).eq('kind', 'photo'); // Only count main photos for primary determination\n        const isFirstPhoto = kind === 'photo' && (!photoCount || photoCount === 0);\n        console.log(\"Upload details: path=\".concat(path, \", kind=\").concat(kind, \", isFirstPhoto=\").concat(isFirstPhoto));\n        // Upload to Storage bucket 'car-media'\n        const { error: upErr } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.storage.from('car-media').upload(path, uploadFile, {\n            contentType: uploadFile.type || originalFile.type,\n            cacheControl: '3600',\n            upsert: false\n        });\n        if (upErr) {\n            console.log(\"Upload failed for \".concat(kind, \":\"), upErr.message);\n            failedArray.push({\n                file: originalFile,\n                error: upErr.message\n            });\n            setFailedFiles([\n                ...failedArray\n            ]);\n            return;\n        }\n        console.log(\"Storage upload successful for \".concat(kind));\n        // Get permanent public URL\n        const { data: pub } = _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.storage.from('car-media').getPublicUrl(path);\n        const url = pub.publicUrl;\n        // Store the public URL in DB with proper kind and sort_order\n        const { error: dbError } = await _lib_supabaseClient__WEBPACK_IMPORTED_MODULE_2__.supabase.from('car_media').insert({\n            car_id: carId,\n            kind: kind,\n            url,\n            is_primary: isFirstPhoto,\n            sort_order: idx\n        });\n        if (dbError) {\n            console.log(\"Database insert failed for \".concat(kind, \":\"), dbError);\n        } else {\n            console.log(\"Successfully saved \".concat(kind, \" to database: \").concat(url));\n        }\n    };\n    const retryFailed = async ()=>{\n        if (!failedFiles.length) return;\n        setRetrying(true);\n        // Retry only failed files\n        const filesToRetry = failedFiles.map((f)=>f.file);\n        setFailedFiles([]);\n        await handleFiles({\n            target: {\n                files: filesToRetry\n            }\n        });\n        setRetrying(false);\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"space-y-1\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                className: \"block text-white/70 text-xs\",\n                children: \"Upload Photos / Videos\"\n            }, void 0, false, {\n                fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                lineNumber: 305,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                type: \"file\",\n                multiple: true,\n                accept: \"image/*,video/*\",\n                onChange: handleFiles,\n                disabled: uploading || retrying,\n                className: \"text-white text-xs\"\n            }, void 0, false, {\n                fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                lineNumber: 306,\n                columnNumber: 7\n            }, this),\n            uploading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"w-full bg-gray-700/50 h-3 rounded overflow-hidden relative\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        className: \"bg-red-500 h-3 transition-all\",\n                        style: {\n                            width: \"\".concat(progress, \"%\")\n                        }\n                    }, void 0, false, {\n                        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                        lineNumber: 316,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                        className: \"absolute inset-0 text-[10px] flex items-center justify-center text-white/80\",\n                        children: [\n                            Math.max(progress, 1),\n                            \"% (\",\n                            Math.round(progress / 100 * totalFiles),\n                            \"/\",\n                            totalFiles,\n                            \")\"\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                        lineNumber: 320,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                lineNumber: 315,\n                columnNumber: 9\n            }, this),\n            failedFiles.length > 0 && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"mt-2 text-xs text-red-400\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: \"Failed to upload:\"\n                    }, void 0, false, {\n                        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                        lineNumber: 327,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n                        className: \"list-disc ml-4\",\n                        children: failedFiles.map((param, idx)=>{\n                            let { file, error } = param;\n                            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                                children: [\n                                    file.name,\n                                    \": \",\n                                    error\n                                ]\n                            }, idx, true, {\n                                fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                                lineNumber: 330,\n                                columnNumber: 15\n                            }, this);\n                        })\n                    }, void 0, false, {\n                        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                        lineNumber: 328,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        className: \"mt-1 px-2 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700\",\n                        onClick: retryFailed,\n                        disabled: retrying,\n                        children: retrying ? 'Retrying...' : 'Retry Failed Uploads'\n                    }, void 0, false, {\n                        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                        lineNumber: 333,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n                lineNumber: 326,\n                columnNumber: 9\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Volumes/SilberArrows/CODEBASE/silberarrows_uv/components/modules/uv-crm/components/MediaUploader.tsx\",\n        lineNumber: 304,\n        columnNumber: 5\n    }, this);\n}\n_s(MediaUploader, \"8VQVnNzTH/Y7+g0IosAIAGTctC0=\");\n_c = MediaUploader;\nvar _c;\n$RefreshReg$(_c, \"MediaUploader\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvbW9kdWxlcy91di1jcm0vY29tcG9uZW50cy9NZWRpYVVwbG9hZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQWlDO0FBQ2U7QUFPaEQsNkVBQTZFO0FBQzdFLE1BQU1FLHNCQUFzQixlQUFPQyxNQUFZQyxhQUFxQkM7UUFBc0JDLGlGQUF5QjtJQUNqSCxPQUFPLElBQUlDLFFBQVEsQ0FBQ0M7UUFDbEIsTUFBTUMsU0FBU0MsU0FBU0MsYUFBYSxDQUFDO1FBQ3RDLE1BQU1DLE1BQU1ILE9BQU9JLFVBQVUsQ0FBQztRQUM5QixNQUFNQyxNQUFNLElBQUlDO1FBRWhCRCxJQUFJRSxNQUFNLEdBQUc7WUFDWFAsT0FBT1EsS0FBSyxHQUFHYjtZQUNmSyxPQUFPUyxNQUFNLEdBQUdiO1lBRWhCLElBQUksQ0FBQ08sS0FBSztnQkFDUkosUUFBUUwsT0FBTywrQ0FBK0M7Z0JBQzlEO1lBQ0Y7WUFFQSxzREFBc0Q7WUFDdEQsSUFBSUcsZUFBZTtnQkFDakIsd0NBQXdDO2dCQUN4QyxNQUFNYSxXQUFXUCxJQUFJUSxvQkFBb0IsQ0FBQyxHQUFHLEdBQUcsR0FBR1gsT0FBT1MsTUFBTTtnQkFDaEVDLFNBQVNFLFlBQVksQ0FBQyxHQUFHLFlBQWEseUJBQXlCO2dCQUMvREYsU0FBU0UsWUFBWSxDQUFDLEtBQUssWUFBWSx1QkFBdUI7Z0JBQzlERixTQUFTRSxZQUFZLENBQUMsR0FBRyxZQUFjLDhCQUE4QjtnQkFFckUsZ0NBQWdDO2dCQUNoQ1QsSUFBSVUsU0FBUyxHQUFHSDtnQkFDaEJQLElBQUlXLFFBQVEsQ0FBQyxHQUFHLEdBQUdkLE9BQU9RLEtBQUssRUFBRVIsT0FBT1MsTUFBTTtZQUNoRDtZQUVBLHNGQUFzRjtZQUN0RixNQUFNTSxpQkFBaUJWLElBQUlHLEtBQUssR0FBR0gsSUFBSUksTUFBTTtZQUM3QyxNQUFNTyxvQkFBb0JyQixjQUFjQztZQUV4QyxJQUFJcUIsV0FBV0MsWUFBWUMsU0FBU0M7WUFFcEMsSUFBSUwsaUJBQWlCQyxtQkFBbUI7Z0JBQ3RDLGdEQUFnRDtnQkFDaERFLGFBQWF0QjtnQkFDYnFCLFlBQVlyQixlQUFlbUI7Z0JBQzNCSSxVQUFVLENBQUN4QixjQUFjc0IsU0FBUSxJQUFLO2dCQUN0Q0csVUFBVTtZQUNaLE9BQU87Z0JBQ0wscURBQXFEO2dCQUNyREgsWUFBWXRCO2dCQUNadUIsYUFBYXZCLGNBQWNvQjtnQkFDM0JJLFVBQVU7Z0JBQ1ZDLFVBQVUsQ0FBQ3hCLGVBQWVzQixVQUFTLElBQUs7WUFDMUM7WUFFQSx3Q0FBd0M7WUFDeENmLElBQUlrQixTQUFTLENBQUNoQixLQUFLYyxTQUFTQyxTQUFTSCxXQUFXQztZQUVoRCx5QkFBeUI7WUFDekJsQixPQUFPc0IsTUFBTSxDQUFDLENBQUNDO2dCQUNiLElBQUlBLE1BQU07b0JBQ1IsTUFBTUMsU0FBUzNCLGdCQUFnQixhQUFjRixnQkFBZ0JDLGVBQWUsWUFBWTtvQkFDeEYsTUFBTTZCLFVBQVUsSUFBSUMsS0FBSzt3QkFBQ0g7cUJBQUssRUFBRTdCLEtBQUtpQyxJQUFJLENBQUNDLE9BQU8sQ0FBQyxXQUFXLEdBQVUsT0FBUEosUUFBTyxVQUFRO3dCQUM5RUssTUFBTTt3QkFDTkMsY0FBY0MsS0FBS0MsR0FBRztvQkFDeEI7b0JBQ0FqQyxRQUFRMEI7Z0JBQ1YsT0FBTztvQkFDTDFCLFFBQVFMLE9BQU8sdUJBQXVCO2dCQUN4QztZQUNGLEdBQUcsYUFBYTtRQUNsQjtRQUVBVyxJQUFJNEIsT0FBTyxHQUFHO1lBQ1psQyxRQUFRTCxPQUFPLDhDQUE4QztRQUMvRDtRQUVBVyxJQUFJNkIsR0FBRyxHQUFHQyxJQUFJQyxlQUFlLENBQUMxQztJQUNoQztBQUNGO0FBRUEsNENBQTRDO0FBQzVDLE1BQU0yQyxxQkFBcUIsT0FBTzNDO0lBQ2hDLElBQUksQ0FBQ0EsS0FBS21DLElBQUksQ0FBQ1MsUUFBUSxDQUFDLFFBQVE7UUFDOUJDLFFBQVFDLEdBQUcsQ0FBQyxRQUFrQixPQUFWOUMsS0FBS2lDLElBQUksRUFBQztRQUM5QixPQUFPO0lBQ1Q7SUFFQSxPQUFPLElBQUk3QixRQUFRLENBQUNDO1FBQ2xCLE1BQU1DLFNBQVNDLFNBQVNDLGFBQWEsQ0FBQztRQUN0QyxNQUFNQyxNQUFNSCxPQUFPSSxVQUFVLENBQUM7UUFDOUIsTUFBTUMsTUFBTSxJQUFJQztRQUVoQkQsSUFBSUUsTUFBTSxHQUFHO1lBQ1hQLE9BQU9RLEtBQUssR0FBR0gsSUFBSUcsS0FBSztZQUN4QlIsT0FBT1MsTUFBTSxHQUFHSixJQUFJSSxNQUFNO1lBRTFCLElBQUksQ0FBQ04sS0FBSztnQkFDUm9DLFFBQVFDLEdBQUcsQ0FBQyxvQ0FBOEMsT0FBVjlDLEtBQUtpQyxJQUFJO2dCQUN6RDVCLFFBQVE7Z0JBQ1I7WUFDRjtZQUVBSSxJQUFJa0IsU0FBUyxDQUFDaEIsS0FBSyxHQUFHO1lBRXRCLElBQUk7Z0JBQ0YsTUFBTW9DLFlBQVl0QyxJQUFJdUMsWUFBWSxDQUFDLEdBQUcsR0FBRzFDLE9BQU9RLEtBQUssRUFBRVIsT0FBT1MsTUFBTTtnQkFDcEUsTUFBTWtDLE9BQU9GLFVBQVVFLElBQUk7Z0JBRTNCLElBQUlDLG9CQUFvQjtnQkFDeEIsSUFBSUMsY0FBY0YsS0FBS0csTUFBTSxHQUFHO2dCQUVoQyx1REFBdUQ7Z0JBQ3ZELElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJSixLQUFLRyxNQUFNLEVBQUVDLEtBQUssRUFBRztvQkFDdkMsSUFBSUosSUFBSSxDQUFDSSxFQUFFLEdBQUcsS0FBSzt3QkFDakJIO29CQUNGO2dCQUNGO2dCQUVBLE1BQU1JLGtCQUFrQkosb0JBQW9CO2dCQUM1Q0wsUUFBUUMsR0FBRyxDQUFDLDZCQUEyQ0ksT0FBZGxELEtBQUtpQyxJQUFJLEVBQUMsTUFBeUJrQixPQUFyQkQsbUJBQWtCLEtBQThDSSxPQUEzQ0gsYUFBWSxpQ0FBK0MsT0FBaEJHO2dCQUN2SGpELFFBQVFpRDtZQUVWLEVBQUUsT0FBT0MsT0FBTztnQkFDZFYsUUFBUUMsR0FBRyxDQUFDLG1DQUE2QyxPQUFWOUMsS0FBS2lDLElBQUksRUFBQyxNQUFJc0I7Z0JBQzdELG9GQUFvRjtnQkFDcEZWLFFBQVFDLEdBQUcsQ0FBQyw2QkFBdUMsT0FBVjlDLEtBQUtpQyxJQUFJLEVBQUM7Z0JBQ25ENUIsUUFBUTtZQUNWO1FBQ0Y7UUFFQU0sSUFBSTRCLE9BQU8sR0FBRyxDQUFDZ0I7WUFDYlYsUUFBUUMsR0FBRyxDQUFDLHVCQUFpQyxPQUFWOUMsS0FBS2lDLElBQUksRUFBQyw2QkFBMkJzQjtZQUN4RWxELFFBQVE7UUFDVjtRQUVBTSxJQUFJNkIsR0FBRyxHQUFHQyxJQUFJQyxlQUFlLENBQUMxQztJQUNoQztBQUNGO0FBRWUsU0FBU3dELGNBQWMsS0FBNEI7UUFBNUIsRUFBRUMsS0FBSyxFQUFFQyxVQUFVLEVBQVMsR0FBNUI7O0lBQ3BDLE1BQU0sQ0FBQ0MsV0FBV0MsYUFBYSxHQUFHL0QsK0NBQVFBLENBQUM7SUFDM0MsTUFBTSxDQUFDZ0UsVUFBVUMsWUFBWSxHQUFHakUsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDa0UsWUFBWUMsY0FBYyxHQUFHbkUsK0NBQVFBLENBQUM7SUFDN0MsTUFBTSxDQUFDb0UsYUFBYUMsZUFBZSxHQUFHckUsK0NBQVFBLENBQWtDLEVBQUU7SUFDbEYsTUFBTSxDQUFDc0UsVUFBVUMsWUFBWSxHQUFHdkUsK0NBQVFBLENBQUM7SUFFekMsTUFBTXdFLGNBQWMsT0FBT0M7UUFDekIsTUFBTUMsUUFBUUMsTUFBTUMsSUFBSSxDQUFDSCxFQUFFSSxNQUFNLENBQUNILEtBQUssSUFBSSxFQUFFO1FBQzdDLElBQUksQ0FBQ0EsTUFBTW5CLE1BQU0sRUFBRTtRQUNuQlEsYUFBYTtRQUNiSSxjQUFjTyxNQUFNbkIsTUFBTTtRQUMxQlUsWUFBWTtRQUNaSSxlQUFlLEVBQUU7UUFFakIsSUFBSVMsU0FBMEMsRUFBRTtRQUVoRCxJQUFLLElBQUlDLE1BQU0sR0FBR0EsTUFBTUwsTUFBTW5CLE1BQU0sRUFBRXdCLE1BQU87WUFDM0MsTUFBTTVFLE9BQU91RSxLQUFLLENBQUNLLElBQUk7WUFFdkIsSUFBSTVFLEtBQUttQyxJQUFJLENBQUMwQyxVQUFVLENBQUMsVUFBVTtnQkFDakMsSUFBSTtvQkFDRix3REFBd0Q7b0JBQ3hELElBQUk3RSxLQUFLbUMsSUFBSSxDQUFDUyxRQUFRLENBQUMsUUFBUTt3QkFDN0JDLFFBQVFDLEdBQUcsQ0FBQyxzQkFBZ0MsT0FBVjlDLEtBQUtpQyxJQUFJLEVBQUM7d0JBQzVDLE1BQU1xQixrQkFBa0IsTUFBTVgsbUJBQW1CM0M7d0JBQ2pENkMsUUFBUUMsR0FBRyxDQUFDLGlDQUErQ1EsT0FBZHRELEtBQUtpQyxJQUFJLEVBQUMsTUFBb0IsT0FBaEJxQjt3QkFFM0QsSUFBSUEsaUJBQWlCOzRCQUNuQlQsUUFBUUMsR0FBRyxDQUFDLCtCQUF5QyxPQUFWOUMsS0FBS2lDLElBQUksRUFBQzs0QkFFckQsb0VBQW9FOzRCQUNwRSxNQUFNNkMsV0FBVztnQ0FDZjtvQ0FDRTlFLE1BQU0sTUFBTUQsb0JBQW9CQyxNQUFNLE1BQU0sTUFBTTtvQ0FDbEQrRSxNQUFNO29DQUNOOUMsTUFBTTtvQ0FDTitDLFVBQVU7Z0NBQ1o7Z0NBQ0E7b0NBQ0VoRixNQUFNLE1BQU1ELG9CQUFvQkMsTUFBTSxNQUFNLE1BQU07b0NBQ2xEK0UsTUFBTTtvQ0FDTjlDLE1BQU07b0NBQ04rQyxVQUFVO2dDQUNaO2dDQUNBO29DQUNFaEYsTUFBTSxNQUFNRCxvQkFBb0JDLE1BQU0sTUFBTSxNQUFNO29DQUNsRCtFLE1BQU07b0NBQ045QyxNQUFNO29DQUNOK0MsVUFBVTtnQ0FDWjs2QkFDRDs0QkFFRG5DLFFBQVFDLEdBQUcsQ0FBQyxXQUEyQzlDLE9BQWhDOEUsU0FBUzFCLE1BQU0sRUFBQyxrQkFBMEIsT0FBVnBELEtBQUtpQyxJQUFJOzRCQUVoRSx3QkFBd0I7NEJBQ3hCLEtBQUssTUFBTWdELFdBQVdILFNBQVU7Z0NBQzlCakMsUUFBUUMsR0FBRyxDQUFDLGFBQWdDbUMsT0FBbkJBLFFBQVFoRCxJQUFJLEVBQUMsUUFBcUNnRCxPQUEvQkEsUUFBUUYsSUFBSSxFQUFDLG9CQUFtQyxPQUFqQkUsUUFBUUQsUUFBUTtnQ0FDM0YsTUFBTUUsb0JBQW9CRCxRQUFRakYsSUFBSSxFQUFFaUYsUUFBUUYsSUFBSSxFQUFFL0UsTUFBTTRFLEtBQUtELFFBQVFNLFFBQVFELFFBQVE7NEJBQzNGO3dCQUNGLE9BQU87NEJBQ0xuQyxRQUFRQyxHQUFHLENBQUMsd0JBQWtDLE9BQVY5QyxLQUFLaUMsSUFBSSxFQUFDOzRCQUM5Qyw2Q0FBNkM7NEJBQzdDLE1BQU1pRCxvQkFBb0JsRixNQUFNLFNBQVNBLE1BQU00RSxLQUFLRDt3QkFDdEQ7b0JBQ0YsT0FBTzt3QkFDTDlCLFFBQVFDLEdBQUcsQ0FBQyxrQkFBNEIsT0FBVjlDLEtBQUtpQyxJQUFJLEVBQUM7d0JBQ3hDLHVDQUF1Qzt3QkFDdkMsTUFBTWlELG9CQUFvQmxGLE1BQU0sU0FBU0EsTUFBTTRFLEtBQUtEO29CQUN0RDtnQkFFRixFQUFFLE9BQU9RLEtBQUs7b0JBQ1p0QyxRQUFRdUMsSUFBSSxDQUFDLCtDQUErQ0Q7b0JBQzVELE1BQU1ELG9CQUFvQmxGLE1BQU0sU0FBU0EsTUFBTTRFLEtBQUtEO2dCQUN0RDtZQUNGLE9BQU87Z0JBQ0wsK0JBQStCO2dCQUMvQixNQUFNTyxvQkFBb0JsRixNQUFNQSxLQUFLbUMsSUFBSSxDQUFDMEMsVUFBVSxDQUFDLFdBQVcsVUFBVSxZQUFZN0UsTUFBTTRFLEtBQUtEO1lBQ25HO1lBRUFiLFlBQVl1QixLQUFLQyxLQUFLLENBQUMsQ0FBRVYsTUFBTSxLQUFLTCxNQUFNbkIsTUFBTSxHQUFJO1FBQ3REO1FBRUFVLFlBQVk7UUFDWnlCLFdBQVc7WUFDVDNCLGFBQWE7WUFDYkUsWUFBWTtZQUNaRSxjQUFjO1lBQ2QsSUFBSU4sWUFBWUE7UUFDbEIsR0FBRztRQUNIWSxFQUFFSSxNQUFNLENBQUNjLEtBQUssR0FBRztJQUNuQjtJQUVBLDZDQUE2QztJQUM3QyxNQUFNTixzQkFBc0IsT0FBT08sWUFBeUJWLE1BQWNXLGNBQW9CZCxLQUFhZSxhQUE4Q1g7UUFDdkpuQyxRQUFRQyxHQUFHLENBQUMseUJBQStDNEMsT0FBdEJYLE1BQUssbUJBQXVEVSxPQUF0Q0MsYUFBYXpELElBQUksRUFBQyxzQkFBaUQrQyxPQUE3QlMsV0FBV0csSUFBSSxFQUFDLGVBQWdDLE9BQW5CWixZQUFZO1FBRTFJLE1BQU1hLE1BQU1ILGFBQWF6RCxJQUFJLENBQUM2RCxLQUFLLENBQUMsS0FBS0MsR0FBRztRQUM1QyxNQUFNQyxlQUFlTixhQUFhekQsSUFBSSxDQUFDQyxPQUFPLENBQUMsYUFBYSxLQUFLLG1CQUFtQjtRQUNwRixNQUFNK0QsaUJBQWlCakIsV0FBVyxHQUFZLE9BQVRBLFVBQVMsT0FBSztRQUNuRCxNQUFNa0IsT0FBTyxHQUFZRCxPQUFUeEMsT0FBTSxLQUFvQjBDLE9BQWpCRixnQkFBd0NKLE9BQXZCTSxPQUFPQyxVQUFVLElBQUcsS0FBTyxPQUFKUDtRQUVqRSxpQ0FBaUM7UUFDakMsTUFBTSxFQUFFUSxPQUFPQyxVQUFVLEVBQUUsR0FBRyxNQUFNeEcseURBQVFBLENBQ3pDMkUsSUFBSSxDQUFDLGFBQ0w4QixNQUFNLENBQUMsS0FBSztZQUFFQyxNQUFNO1lBQU1ILE9BQU87UUFBUSxHQUN6Q0ksRUFBRSxDQUFDLFVBQVVoRCxPQUNiZ0QsRUFBRSxDQUFDLFFBQVEsVUFBVSxtREFBbUQ7UUFDM0UsTUFBTUMsZUFBZTNCLFNBQVMsV0FBWSxFQUFDdUIsY0FBY0EsZUFBZTtRQUV4RXpELFFBQVFDLEdBQUcsQ0FBQyx3QkFBc0NpQyxPQUFkbUIsTUFBSyxXQUErQlEsT0FBdEIzQixNQUFLLG1CQUE4QixPQUFiMkI7UUFFeEUsdUNBQXVDO1FBQ3ZDLE1BQU0sRUFBRW5ELE9BQU9vRCxLQUFLLEVBQUUsR0FBRyxNQUFNN0cseURBQVFBLENBQUM4RyxPQUFPLENBQzVDbkMsSUFBSSxDQUFDLGFBQ0xvQyxNQUFNLENBQUNYLE1BQU1ULFlBQVk7WUFDeEJxQixhQUFhckIsV0FBV3RELElBQUksSUFBSXVELGFBQWF2RCxJQUFJO1lBQ2pENEUsY0FBYztZQUNkQyxRQUFRO1FBQ1Y7UUFFRixJQUFJTCxPQUFPO1lBQ1Q5RCxRQUFRQyxHQUFHLENBQUMscUJBQTBCLE9BQUxpQyxNQUFLLE1BQUk0QixNQUFNTSxPQUFPO1lBQ3ZEdEIsWUFBWXVCLElBQUksQ0FBQztnQkFBRWxILE1BQU0wRjtnQkFBY25DLE9BQU9vRCxNQUFNTSxPQUFPO1lBQUM7WUFDNUQvQyxlQUFlO21CQUFJeUI7YUFBWTtZQUMvQjtRQUNGO1FBRUE5QyxRQUFRQyxHQUFHLENBQUMsaUNBQXNDLE9BQUxpQztRQUU3QywyQkFBMkI7UUFDM0IsTUFBTSxFQUFFOUIsTUFBTWtFLEdBQUcsRUFBRSxHQUFHckgseURBQVFBLENBQUM4RyxPQUFPLENBQUNuQyxJQUFJLENBQUMsYUFBYTJDLFlBQVksQ0FBQ2xCO1FBQ3RFLE1BQU1tQixNQUFNRixJQUFJRyxTQUFTO1FBRXpCLDZEQUE2RDtRQUM3RCxNQUFNLEVBQUUvRCxPQUFPZ0UsT0FBTyxFQUFFLEdBQUcsTUFBTXpILHlEQUFRQSxDQUFDMkUsSUFBSSxDQUFDLGFBQWErQyxNQUFNLENBQUM7WUFDakVDLFFBQVFoRTtZQUNSc0IsTUFBTUE7WUFDTnNDO1lBQ0FLLFlBQVloQjtZQUNaaUIsWUFBWS9DO1FBQ2Q7UUFFQSxJQUFJMkMsU0FBUztZQUNYMUUsUUFBUUMsR0FBRyxDQUFDLDhCQUFtQyxPQUFMaUMsTUFBSyxNQUFJd0M7UUFDckQsT0FBTztZQUNMMUUsUUFBUUMsR0FBRyxDQUFDLHNCQUEyQ3VFLE9BQXJCdEMsTUFBSyxrQkFBb0IsT0FBSnNDO1FBQ3pEO0lBQ0Y7SUFFQSxNQUFNTyxjQUFjO1FBQ2xCLElBQUksQ0FBQzNELFlBQVliLE1BQU0sRUFBRTtRQUN6QmdCLFlBQVk7UUFDWiwwQkFBMEI7UUFDMUIsTUFBTXlELGVBQWU1RCxZQUFZNkQsR0FBRyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFL0gsSUFBSTtRQUNoRGtFLGVBQWUsRUFBRTtRQUNqQixNQUFNRyxZQUFZO1lBQUVLLFFBQVE7Z0JBQUVILE9BQU9zRDtZQUFhO1FBQUU7UUFDcER6RCxZQUFZO0lBQ2Q7SUFFQSxxQkFDRSw4REFBQzREO1FBQUlDLFdBQVU7OzBCQUNiLDhEQUFDQztnQkFBTUQsV0FBVTswQkFBOEI7Ozs7OzswQkFDL0MsOERBQUNFO2dCQUNDaEcsTUFBSztnQkFDTGlHLFFBQVE7Z0JBQ1JDLFFBQU87Z0JBQ1BDLFVBQVVqRTtnQkFDVmtFLFVBQVU1RSxhQUFhUTtnQkFDdkI4RCxXQUFVOzs7Ozs7WUFFWHRFLDJCQUNDLDhEQUFDcUU7Z0JBQUlDLFdBQVU7O2tDQUNiLDhEQUFDRDt3QkFDQ0MsV0FBVTt3QkFDVk8sT0FBTzs0QkFBRTFILE9BQU8sR0FBWSxPQUFUK0MsVUFBUzt3QkFBRzs7Ozs7O2tDQUVqQyw4REFBQzRFO3dCQUFLUixXQUFVOzs0QkFDYjVDLEtBQUtxRCxHQUFHLENBQUM3RSxVQUFVOzRCQUFHOzRCQUFJd0IsS0FBS0MsS0FBSyxDQUFDLFdBQVksTUFBT3ZCOzRCQUFZOzRCQUFFQTs0QkFBVzs7Ozs7Ozs7Ozs7OztZQUl2RkUsWUFBWWIsTUFBTSxHQUFHLG1CQUNwQiw4REFBQzRFO2dCQUFJQyxXQUFVOztrQ0FDYiw4REFBQ0Q7a0NBQUk7Ozs7OztrQ0FDTCw4REFBQ1c7d0JBQUdWLFdBQVU7a0NBQ1hoRSxZQUFZNkQsR0FBRyxDQUFDLFFBQWtCbEQ7Z0NBQWpCLEVBQUU1RSxJQUFJLEVBQUV1RCxLQUFLLEVBQUU7aURBQy9CLDhEQUFDcUY7O29DQUFjNUksS0FBS2lDLElBQUk7b0NBQUM7b0NBQUdzQjs7K0JBQW5CcUI7Ozs7Ozs7Ozs7O2tDQUdiLDhEQUFDaUU7d0JBQ0NaLFdBQVU7d0JBQ1ZhLFNBQVNsQjt3QkFDVFcsVUFBVXBFO2tDQUVUQSxXQUFXLGdCQUFnQjs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBTXhDO0dBek13Qlg7S0FBQUEiLCJzb3VyY2VzIjpbIi9Wb2x1bWVzL1NpbGJlckFycm93cy9DT0RFQkFTRS9zaWxiZXJhcnJvd3NfdXYvY29tcG9uZW50cy9tb2R1bGVzL3V2LWNybS9jb21wb25lbnRzL01lZGlhVXBsb2FkZXIudHN4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgc3VwYWJhc2UgfSBmcm9tICdAL2xpYi9zdXBhYmFzZUNsaWVudCc7XG5cbmludGVyZmFjZSBQcm9wcyB7XG4gIGNhcklkOiBzdHJpbmc7XG4gIG9uVXBsb2FkZWQ/OiAoKSA9PiB2b2lkO1xufVxuXG4vLyBGdW5jdGlvbiB0byBjb252ZXJ0IGltYWdlIHRvIHNwZWNpZmljIHJhdGlvIHdoaWxlIG1haW50YWluaW5nIHRyYW5zcGFyZW5jeVxuY29uc3QgcHJvY2Vzc0ltYWdlVG9SYXRpbyA9IGFzeW5jIChmaWxlOiBGaWxlLCB0YXJnZXRXaWR0aDogbnVtYmVyLCB0YXJnZXRIZWlnaHQ6IG51bWJlciwgYWRkQmFja2dyb3VuZDogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTxGaWxlPiA9PiB7XG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjYW52YXMud2lkdGggPSB0YXJnZXRXaWR0aDtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XG4gICAgICBcbiAgICAgIGlmICghY3R4KSB7XG4gICAgICAgIHJlc29sdmUoZmlsZSk7IC8vIGZhbGxiYWNrIHRvIG9yaWdpbmFsIGlmIGNhbnZhcyBjb250ZXh0IGZhaWxzXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gQWRkIGJhY2tncm91bmQgb25seSBpZiByZXF1ZXN0ZWQgKGZvciBtYWluIHZlcnNpb24pXG4gICAgICBpZiAoYWRkQmFja2dyb3VuZCkge1xuICAgICAgICAvLyBDcmVhdGUgbGlnaHQgZ3JleSBncmFkaWVudCBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnN0IGdyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KDAsIDAsIDAsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBncmFkaWVudC5hZGRDb2xvclN0b3AoMCwgJyNmOGY4ZjgnKTsgIC8vIFZlcnkgbGlnaHQgZ3JleSBhdCB0b3BcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDAuNSwgJyNlOGU4ZTgnKTsgLy8gTGlnaHQgZ3JleSBpbiBtaWRkbGVcbiAgICAgICAgZ3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjZDhkOGQ4Jyk7ICAgLy8gTWVkaXVtIGxpZ2h0IGdyZXkgYXQgYm90dG9tXG4gICAgICAgIFxuICAgICAgICAvLyBGaWxsIGJhY2tncm91bmQgd2l0aCBncmFkaWVudFxuICAgICAgICBjdHguZmlsbFN0eWxlID0gZ3JhZGllbnQ7XG4gICAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgXG4gICAgICAvLyBDYWxjdWxhdGUgc2NhbGluZyB0byBmaWxsIGVudGlyZSBjYW52YXMgd2hpbGUgbWFpbnRhaW5pbmcgYXNwZWN0IHJhdGlvIChjb3ZlciBtb2RlKVxuICAgICAgY29uc3QgaW1nQXNwZWN0UmF0aW8gPSBpbWcud2lkdGggLyBpbWcuaGVpZ2h0O1xuICAgICAgY29uc3QgY2FudmFzQXNwZWN0UmF0aW8gPSB0YXJnZXRXaWR0aCAvIHRhcmdldEhlaWdodDtcbiAgICAgIFxuICAgICAgbGV0IGRyYXdXaWR0aCwgZHJhd0hlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WTtcbiAgICAgIFxuICAgICAgaWYgKGltZ0FzcGVjdFJhdGlvID4gY2FudmFzQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgLy8gSW1hZ2UgaXMgd2lkZXIgLSBmaXQgdG8gaGVpZ2h0IGFuZCBjcm9wIHNpZGVzXG4gICAgICAgIGRyYXdIZWlnaHQgPSB0YXJnZXRIZWlnaHQ7XG4gICAgICAgIGRyYXdXaWR0aCA9IHRhcmdldEhlaWdodCAqIGltZ0FzcGVjdFJhdGlvO1xuICAgICAgICBvZmZzZXRYID0gKHRhcmdldFdpZHRoIC0gZHJhd1dpZHRoKSAvIDI7XG4gICAgICAgIG9mZnNldFkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSW1hZ2UgaXMgdGFsbGVyIC0gZml0IHRvIHdpZHRoIGFuZCBjcm9wIHRvcC9ib3R0b21cbiAgICAgICAgZHJhd1dpZHRoID0gdGFyZ2V0V2lkdGg7XG4gICAgICAgIGRyYXdIZWlnaHQgPSB0YXJnZXRXaWR0aCAvIGltZ0FzcGVjdFJhdGlvO1xuICAgICAgICBvZmZzZXRYID0gMDtcbiAgICAgICAgb2Zmc2V0WSA9ICh0YXJnZXRIZWlnaHQgLSBkcmF3SGVpZ2h0KSAvIDI7XG4gICAgICB9XG4gICAgICBcbiAgICAgIC8vIERyYXcgdGhlIGltYWdlIGNlbnRlcmVkIG9uIHRoZSBjYW52YXNcbiAgICAgIGN0eC5kcmF3SW1hZ2UoaW1nLCBvZmZzZXRYLCBvZmZzZXRZLCBkcmF3V2lkdGgsIGRyYXdIZWlnaHQpO1xuICAgICAgXG4gICAgICAvLyBDb252ZXJ0IGNhbnZhcyB0byBmaWxlXG4gICAgICBjYW52YXMudG9CbG9iKChibG9iKSA9PiB7XG4gICAgICAgIGlmIChibG9iKSB7XG4gICAgICAgICAgY29uc3Qgc3VmZml4ID0gYWRkQmFja2dyb3VuZCA/ICdfd2l0aF9iZycgOiAodGFyZ2V0V2lkdGggPT09IHRhcmdldEhlaWdodCA/ICdfc3F1YXJlJyA6ICdfNHg1Jyk7XG4gICAgICAgICAgY29uc3QgbmV3RmlsZSA9IG5ldyBGaWxlKFtibG9iXSwgZmlsZS5uYW1lLnJlcGxhY2UoL1xcLnBuZyQvaSwgYCR7c3VmZml4fS5wbmdgKSwge1xuICAgICAgICAgICAgdHlwZTogJ2ltYWdlL3BuZycsXG4gICAgICAgICAgICBsYXN0TW9kaWZpZWQ6IERhdGUubm93KClcbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXNvbHZlKG5ld0ZpbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZmlsZSk7IC8vIGZhbGxiYWNrIHRvIG9yaWdpbmFsXG4gICAgICAgIH1cbiAgICAgIH0sICdpbWFnZS9wbmcnLCAwLjk1KTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKCkgPT4ge1xuICAgICAgcmVzb2x2ZShmaWxlKTsgLy8gZmFsbGJhY2sgdG8gb3JpZ2luYWwgaWYgaW1hZ2UgbG9hZGluZyBmYWlsc1xuICAgIH07XG4gICAgXG4gICAgaW1nLnNyYyA9IFVSTC5jcmVhdGVPYmplY3RVUkwoZmlsZSk7XG4gIH0pO1xufTtcblxuLy8gRnVuY3Rpb24gdG8gY2hlY2sgaWYgUE5HIGhhcyB0cmFuc3BhcmVuY3lcbmNvbnN0IGhhc1BuZ1RyYW5zcGFyZW5jeSA9IGFzeW5jIChmaWxlOiBGaWxlKTogUHJvbWlzZTxib29sZWFuPiA9PiB7XG4gIGlmICghZmlsZS50eXBlLmluY2x1ZGVzKCdwbmcnKSkge1xuICAgIGNvbnNvbGUubG9nKGBGaWxlICR7ZmlsZS5uYW1lfSBpcyBub3QgUE5HLCBza2lwcGluZyB0cmFuc3BhcmVuY3kgY2hlY2tgKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpO1xuICAgIFxuICAgIGltZy5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICBjYW52YXMud2lkdGggPSBpbWcud2lkdGg7XG4gICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgIFxuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYEZhaWxlZCB0byBnZXQgY2FudmFzIGNvbnRleHQgZm9yICR7ZmlsZS5uYW1lfWApO1xuICAgICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgXG4gICAgICBjdHguZHJhd0ltYWdlKGltZywgMCwgMCk7XG4gICAgICBcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuICAgICAgICBcbiAgICAgICAgbGV0IHRyYW5zcGFyZW50UGl4ZWxzID0gMDtcbiAgICAgICAgbGV0IHRvdGFsUGl4ZWxzID0gZGF0YS5sZW5ndGggLyA0O1xuICAgICAgICBcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFueSBwaXhlbHMgd2l0aCBhbHBoYSA8IDI1NSAodHJhbnNwYXJlbmN5KVxuICAgICAgICBmb3IgKGxldCBpID0gMzsgaSA8IGRhdGEubGVuZ3RoOyBpICs9IDQpIHtcbiAgICAgICAgICBpZiAoZGF0YVtpXSA8IDI1NSkge1xuICAgICAgICAgICAgdHJhbnNwYXJlbnRQaXhlbHMrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnN0IGhhc1RyYW5zcGFyZW5jeSA9IHRyYW5zcGFyZW50UGl4ZWxzID4gMDtcbiAgICAgICAgY29uc29sZS5sb2coYFRyYW5zcGFyZW5jeSBhbmFseXNpcyBmb3IgJHtmaWxlLm5hbWV9OiAke3RyYW5zcGFyZW50UGl4ZWxzfS8ke3RvdGFsUGl4ZWxzfSB0cmFuc3BhcmVudCBwaXhlbHMsIHJlc3VsdDogJHtoYXNUcmFuc3BhcmVuY3l9YCk7XG4gICAgICAgIHJlc29sdmUoaGFzVHJhbnNwYXJlbmN5KTtcbiAgICAgICAgXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3IgY2hlY2tpbmcgdHJhbnNwYXJlbmN5IGZvciAke2ZpbGUubmFtZX06YCwgZXJyb3IpO1xuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBhY2Nlc3MgaW1hZ2UgZGF0YSAoQ09SUywgZXRjLiksIGFzc3VtZSBpdCBoYXMgdHJhbnNwYXJlbmN5IHRvIGJlIHNhZmVcbiAgICAgICAgY29uc29sZS5sb2coYEFzc3VtaW5nIHRyYW5zcGFyZW5jeSBmb3IgJHtmaWxlLm5hbWV9IGR1ZSB0byBhY2Nlc3MgZXJyb3JgKTtcbiAgICAgICAgcmVzb2x2ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGltZy5vbmVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhgRXJyb3IgbG9hZGluZyBpbWFnZSAke2ZpbGUubmFtZX0gZm9yIHRyYW5zcGFyZW5jeSBjaGVjazpgLCBlcnJvcik7XG4gICAgICByZXNvbHZlKGZhbHNlKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGZpbGUpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE1lZGlhVXBsb2FkZXIoeyBjYXJJZCwgb25VcGxvYWRlZCB9OiBQcm9wcykge1xuICBjb25zdCBbdXBsb2FkaW5nLCBzZXRVcGxvYWRpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICBjb25zdCBbcHJvZ3Jlc3MsIHNldFByb2dyZXNzXSA9IHVzZVN0YXRlKDApO1xuICBjb25zdCBbdG90YWxGaWxlcywgc2V0VG90YWxGaWxlc10gPSB1c2VTdGF0ZSgwKTtcbiAgY29uc3QgW2ZhaWxlZEZpbGVzLCBzZXRGYWlsZWRGaWxlc10gPSB1c2VTdGF0ZTx7IGZpbGU6IEZpbGUsIGVycm9yOiBzdHJpbmcgfVtdPihbXSk7XG4gIGNvbnN0IFtyZXRyeWluZywgc2V0UmV0cnlpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIGNvbnN0IGhhbmRsZUZpbGVzID0gYXN5bmMgKGU6IFJlYWN0LkNoYW5nZUV2ZW50PEhUTUxJbnB1dEVsZW1lbnQ+KSA9PiB7XG4gICAgY29uc3QgZmlsZXMgPSBBcnJheS5mcm9tKGUudGFyZ2V0LmZpbGVzIHx8IFtdKTtcbiAgICBpZiAoIWZpbGVzLmxlbmd0aCkgcmV0dXJuO1xuICAgIHNldFVwbG9hZGluZyh0cnVlKTtcbiAgICBzZXRUb3RhbEZpbGVzKGZpbGVzLmxlbmd0aCk7XG4gICAgc2V0UHJvZ3Jlc3MoMCk7XG4gICAgc2V0RmFpbGVkRmlsZXMoW10pO1xuXG4gICAgbGV0IGZhaWxlZDogeyBmaWxlOiBGaWxlLCBlcnJvcjogc3RyaW5nIH1bXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZmlsZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgY29uc3QgZmlsZSA9IGZpbGVzW2lkeF07XG4gICAgICBcbiAgICAgIGlmIChmaWxlLnR5cGUuc3RhcnRzV2l0aCgnaW1hZ2UnKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIENoZWNrIGlmIFBORyBoYXMgdHJhbnNwYXJlbmN5IGFuZCBwcm9jZXNzIGFjY29yZGluZ2x5XG4gICAgICAgICAgaWYgKGZpbGUudHlwZS5pbmNsdWRlcygncG5nJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQTkcgZmlsZSBkZXRlY3RlZDogJHtmaWxlLm5hbWV9LCBjaGVja2luZyB0cmFuc3BhcmVuY3kuLi5gKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1RyYW5zcGFyZW5jeSA9IGF3YWl0IGhhc1BuZ1RyYW5zcGFyZW5jeShmaWxlKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUcmFuc3BhcmVuY3kgY2hlY2sgcmVzdWx0IGZvciAke2ZpbGUubmFtZX06ICR7aGFzVHJhbnNwYXJlbmN5fWApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNwYXJlbmN5KSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHRyYW5zcGFyZW50IFBORzogJHtmaWxlLm5hbWV9IGludG8gMyB2ZXJzaW9uc2ApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gQ3JlYXRlIDMgdmVyc2lvbnMgZm9yIHRyYW5zcGFyZW50IFBOR3MgLSBhbGwgd2l0aCBncmV5IGJhY2tncm91bmRcbiAgICAgICAgICAgICAgY29uc3QgdmVyc2lvbnMgPSBbXG4gICAgICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgICAgIGZpbGU6IGF3YWl0IHByb2Nlc3NJbWFnZVRvUmF0aW8oZmlsZSwgMTYwMCwgMTIwMCwgdHJ1ZSksIC8vIE1haW4gd2l0aCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICBraW5kOiAncGhvdG8nLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ01haW4gKHdpdGggYmFja2dyb3VuZCknLFxuICAgICAgICAgICAgICAgICAgbWV0YWRhdGE6ICdtYWluJ1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeyBcbiAgICAgICAgICAgICAgICAgIGZpbGU6IGF3YWl0IHByb2Nlc3NJbWFnZVRvUmF0aW8oZmlsZSwgMTA4MCwgMTM1MCwgdHJ1ZSksIC8vIDQ6NSB3aXRoIGJhY2tncm91bmRcbiAgICAgICAgICAgICAgICAgIGtpbmQ6ICdwaG90bycsIFxuICAgICAgICAgICAgICAgICAgbmFtZTogJzQ6NSBSYXRpbyAod2l0aCBiYWNrZ3JvdW5kKScsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YTogJzR4NSdcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHsgXG4gICAgICAgICAgICAgICAgICBmaWxlOiBhd2FpdCBwcm9jZXNzSW1hZ2VUb1JhdGlvKGZpbGUsIDEwODAsIDEwODAsIHRydWUpLCAvLyAxOjEgd2l0aCBiYWNrZ3JvdW5kXG4gICAgICAgICAgICAgICAgICBraW5kOiAncGhvdG8nLFxuICAgICAgICAgICAgICAgICAgbmFtZTogJ1NxdWFyZSAod2l0aCBiYWNrZ3JvdW5kKScsXG4gICAgICAgICAgICAgICAgICBtZXRhZGF0YTogJ3NxdWFyZSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgQ3JlYXRlZCAke3ZlcnNpb25zLmxlbmd0aH0gdmVyc2lvbnMgZm9yICR7ZmlsZS5uYW1lfWApO1xuICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgLy8gVXBsb2FkIGFsbCAzIHZlcnNpb25zXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgdmVyc2lvbiBvZiB2ZXJzaW9ucykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGxvYWRpbmcgJHt2ZXJzaW9uLm5hbWV9IGFzICR7dmVyc2lvbi5raW5kfSB3aXRoIG1ldGFkYXRhOiAke3ZlcnNpb24ubWV0YWRhdGF9YCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkU2luZ2xlVmVyc2lvbih2ZXJzaW9uLmZpbGUsIHZlcnNpb24ua2luZCwgZmlsZSwgaWR4LCBmYWlsZWQsIHZlcnNpb24ubWV0YWRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgTm9uLXRyYW5zcGFyZW50IFBORzogJHtmaWxlLm5hbWV9LCB1cGxvYWRpbmcgb3JpZ2luYWwgb25seWApO1xuICAgICAgICAgICAgICAvLyBOb24tdHJhbnNwYXJlbnQgUE5HIC0ganVzdCB1cGxvYWQgb3JpZ2luYWxcbiAgICAgICAgICAgICAgYXdhaXQgdXBsb2FkU2luZ2xlVmVyc2lvbihmaWxlLCAncGhvdG8nLCBmaWxlLCBpZHgsIGZhaWxlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBOb24tUE5HIGltYWdlOiAke2ZpbGUubmFtZX0sIHVwbG9hZGluZyBvcmlnaW5hbCBvbmx5YCk7XG4gICAgICAgICAgICAvLyBOb24tUE5HIGltYWdlIC0ganVzdCB1cGxvYWQgb3JpZ2luYWxcbiAgICAgICAgICAgIGF3YWl0IHVwbG9hZFNpbmdsZVZlcnNpb24oZmlsZSwgJ3Bob3RvJywgZmlsZSwgaWR4LCBmYWlsZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdJbWFnZSBwcm9jZXNzaW5nIGZhaWxlZCwgdXBsb2FkaW5nIG9yaWdpbmFsJywgZXJyKTtcbiAgICAgICAgICBhd2FpdCB1cGxvYWRTaW5nbGVWZXJzaW9uKGZpbGUsICdwaG90bycsIGZpbGUsIGlkeCwgZmFpbGVkKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm9uLWltYWdlIGZpbGUgKHZpZGVvLCBldGMuKVxuICAgICAgICBhd2FpdCB1cGxvYWRTaW5nbGVWZXJzaW9uKGZpbGUsIGZpbGUudHlwZS5zdGFydHNXaXRoKCd2aWRlbycpID8gJ3ZpZGVvJyA6ICdkb2N1bWVudCcsIGZpbGUsIGlkeCwgZmFpbGVkKTtcbiAgICAgIH1cblxuICAgICAgc2V0UHJvZ3Jlc3MoTWF0aC5yb3VuZCgoKGlkeCArIDEpIC8gZmlsZXMubGVuZ3RoKSAqIDEwMCkpO1xuICAgIH1cblxuICAgIHNldFByb2dyZXNzKDEwMCk7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzZXRVcGxvYWRpbmcoZmFsc2UpO1xuICAgICAgc2V0UHJvZ3Jlc3MoMCk7XG4gICAgICBzZXRUb3RhbEZpbGVzKDApO1xuICAgICAgaWYgKG9uVXBsb2FkZWQpIG9uVXBsb2FkZWQoKTtcbiAgICB9LCA4MDApO1xuICAgIGUudGFyZ2V0LnZhbHVlID0gJyc7XG4gIH07XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIHVwbG9hZCBhIHNpbmdsZSB2ZXJzaW9uXG4gIGNvbnN0IHVwbG9hZFNpbmdsZVZlcnNpb24gPSBhc3luYyAodXBsb2FkRmlsZTogRmlsZSB8IEJsb2IsIGtpbmQ6IHN0cmluZywgb3JpZ2luYWxGaWxlOiBGaWxlLCBpZHg6IG51bWJlciwgZmFpbGVkQXJyYXk6IHsgZmlsZTogRmlsZSwgZXJyb3I6IHN0cmluZyB9W10sIG1ldGFkYXRhPzogc3RyaW5nKSA9PiB7XG4gICAgY29uc29sZS5sb2coYFN0YXJ0aW5nIHVwbG9hZDoga2luZD0ke2tpbmR9LCBvcmlnaW5hbEZpbGU9JHtvcmlnaW5hbEZpbGUubmFtZX0sIHVwbG9hZEZpbGUgc2l6ZT0ke3VwbG9hZEZpbGUuc2l6ZX0sIG1ldGFkYXRhPSR7bWV0YWRhdGEgfHwgJ25vbmUnfWApO1xuICAgIFxuICAgIGNvbnN0IGV4dCA9IG9yaWdpbmFsRmlsZS5uYW1lLnNwbGl0KCcuJykucG9wKCk7XG4gICAgY29uc3QgYmFzZUZpbGVOYW1lID0gb3JpZ2luYWxGaWxlLm5hbWUucmVwbGFjZSgvXFwuW14vLl0rJC8sIFwiXCIpOyAvLyBSZW1vdmUgZXh0ZW5zaW9uXG4gICAgY29uc3QgbWV0YWRhdGFQcmVmaXggPSBtZXRhZGF0YSA/IGAke21ldGFkYXRhfS1gIDogJyc7XG4gICAgY29uc3QgcGF0aCA9IGAke2NhcklkfS8ke21ldGFkYXRhUHJlZml4fSR7Y3J5cHRvLnJhbmRvbVVVSUQoKX0uJHtleHR9YDtcblxuICAgIC8vIENoZWNrIGlmIGNhciBhbHJlYWR5IGhhcyBtZWRpYVxuICAgIGNvbnN0IHsgY291bnQ6IHBob3RvQ291bnQgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAuZnJvbSgnY2FyX21lZGlhJylcbiAgICAgIC5zZWxlY3QoJyonLCB7IGhlYWQ6IHRydWUsIGNvdW50OiAnZXhhY3QnIH0pXG4gICAgICAuZXEoJ2Nhcl9pZCcsIGNhcklkKVxuICAgICAgLmVxKCdraW5kJywgJ3Bob3RvJyk7IC8vIE9ubHkgY291bnQgbWFpbiBwaG90b3MgZm9yIHByaW1hcnkgZGV0ZXJtaW5hdGlvblxuICAgIGNvbnN0IGlzRmlyc3RQaG90byA9IGtpbmQgPT09ICdwaG90bycgJiYgKCFwaG90b0NvdW50IHx8IHBob3RvQ291bnQgPT09IDApO1xuXG4gICAgY29uc29sZS5sb2coYFVwbG9hZCBkZXRhaWxzOiBwYXRoPSR7cGF0aH0sIGtpbmQ9JHtraW5kfSwgaXNGaXJzdFBob3RvPSR7aXNGaXJzdFBob3RvfWApO1xuXG4gICAgLy8gVXBsb2FkIHRvIFN0b3JhZ2UgYnVja2V0ICdjYXItbWVkaWEnXG4gICAgY29uc3QgeyBlcnJvcjogdXBFcnIgfSA9IGF3YWl0IHN1cGFiYXNlLnN0b3JhZ2VcbiAgICAgIC5mcm9tKCdjYXItbWVkaWEnKVxuICAgICAgLnVwbG9hZChwYXRoLCB1cGxvYWRGaWxlLCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiB1cGxvYWRGaWxlLnR5cGUgfHwgb3JpZ2luYWxGaWxlLnR5cGUsXG4gICAgICAgIGNhY2hlQ29udHJvbDogJzM2MDAnLFxuICAgICAgICB1cHNlcnQ6IGZhbHNlLFxuICAgICAgfSk7XG4gICAgXG4gICAgaWYgKHVwRXJyKSB7XG4gICAgICBjb25zb2xlLmxvZyhgVXBsb2FkIGZhaWxlZCBmb3IgJHtraW5kfTpgLCB1cEVyci5tZXNzYWdlKTtcbiAgICAgIGZhaWxlZEFycmF5LnB1c2goeyBmaWxlOiBvcmlnaW5hbEZpbGUsIGVycm9yOiB1cEVyci5tZXNzYWdlIH0pO1xuICAgICAgc2V0RmFpbGVkRmlsZXMoWy4uLmZhaWxlZEFycmF5XSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc29sZS5sb2coYFN0b3JhZ2UgdXBsb2FkIHN1Y2Nlc3NmdWwgZm9yICR7a2luZH1gKTtcblxuICAgIC8vIEdldCBwZXJtYW5lbnQgcHVibGljIFVSTFxuICAgIGNvbnN0IHsgZGF0YTogcHViIH0gPSBzdXBhYmFzZS5zdG9yYWdlLmZyb20oJ2Nhci1tZWRpYScpLmdldFB1YmxpY1VybChwYXRoKTtcbiAgICBjb25zdCB1cmwgPSBwdWIucHVibGljVXJsO1xuXG4gICAgLy8gU3RvcmUgdGhlIHB1YmxpYyBVUkwgaW4gREIgd2l0aCBwcm9wZXIga2luZCBhbmQgc29ydF9vcmRlclxuICAgIGNvbnN0IHsgZXJyb3I6IGRiRXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLmZyb20oJ2Nhcl9tZWRpYScpLmluc2VydCh7XG4gICAgICBjYXJfaWQ6IGNhcklkLFxuICAgICAga2luZDoga2luZCxcbiAgICAgIHVybCxcbiAgICAgIGlzX3ByaW1hcnk6IGlzRmlyc3RQaG90byxcbiAgICAgIHNvcnRfb3JkZXI6IGlkeCxcbiAgICB9KTtcblxuICAgIGlmIChkYkVycm9yKSB7XG4gICAgICBjb25zb2xlLmxvZyhgRGF0YWJhc2UgaW5zZXJ0IGZhaWxlZCBmb3IgJHtraW5kfTpgLCBkYkVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBzYXZlZCAke2tpbmR9IHRvIGRhdGFiYXNlOiAke3VybH1gKTtcbiAgICB9XG4gIH07XG5cbiAgY29uc3QgcmV0cnlGYWlsZWQgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKCFmYWlsZWRGaWxlcy5sZW5ndGgpIHJldHVybjtcbiAgICBzZXRSZXRyeWluZyh0cnVlKTtcbiAgICAvLyBSZXRyeSBvbmx5IGZhaWxlZCBmaWxlc1xuICAgIGNvbnN0IGZpbGVzVG9SZXRyeSA9IGZhaWxlZEZpbGVzLm1hcChmID0+IGYuZmlsZSk7XG4gICAgc2V0RmFpbGVkRmlsZXMoW10pO1xuICAgIGF3YWl0IGhhbmRsZUZpbGVzKHsgdGFyZ2V0OiB7IGZpbGVzOiBmaWxlc1RvUmV0cnkgfSB9IGFzIGFueSk7XG4gICAgc2V0UmV0cnlpbmcoZmFsc2UpO1xuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTFcIj5cbiAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayB0ZXh0LXdoaXRlLzcwIHRleHQteHNcIj5VcGxvYWQgUGhvdG9zIC8gVmlkZW9zPC9sYWJlbD5cbiAgICAgIDxpbnB1dFxuICAgICAgICB0eXBlPVwiZmlsZVwiXG4gICAgICAgIG11bHRpcGxlXG4gICAgICAgIGFjY2VwdD1cImltYWdlLyosdmlkZW8vKlwiXG4gICAgICAgIG9uQ2hhbmdlPXtoYW5kbGVGaWxlc31cbiAgICAgICAgZGlzYWJsZWQ9e3VwbG9hZGluZyB8fCByZXRyeWluZ31cbiAgICAgICAgY2xhc3NOYW1lPVwidGV4dC13aGl0ZSB0ZXh0LXhzXCJcbiAgICAgIC8+XG4gICAgICB7dXBsb2FkaW5nICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3LWZ1bGwgYmctZ3JheS03MDAvNTAgaC0zIHJvdW5kZWQgb3ZlcmZsb3ctaGlkZGVuIHJlbGF0aXZlXCI+XG4gICAgICAgICAgPGRpdlxuICAgICAgICAgICAgY2xhc3NOYW1lPVwiYmctcmVkLTUwMCBoLTMgdHJhbnNpdGlvbi1hbGxcIlxuICAgICAgICAgICAgc3R5bGU9e3sgd2lkdGg6IGAke3Byb2dyZXNzfSVgIH19XG4gICAgICAgICAgLz5cbiAgICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIHRleHQtWzEwcHhdIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyIHRleHQtd2hpdGUvODBcIj5cbiAgICAgICAgICAgIHtNYXRoLm1heChwcm9ncmVzcywgMSl9JSAoe01hdGgucm91bmQoKHByb2dyZXNzIC8gMTAwKSAqIHRvdGFsRmlsZXMpfS97dG90YWxGaWxlc30pXG4gICAgICAgICAgPC9zcGFuPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICB7ZmFpbGVkRmlsZXMubGVuZ3RoID4gMCAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibXQtMiB0ZXh0LXhzIHRleHQtcmVkLTQwMFwiPlxuICAgICAgICAgIDxkaXY+RmFpbGVkIHRvIHVwbG9hZDo8L2Rpdj5cbiAgICAgICAgICA8dWwgY2xhc3NOYW1lPVwibGlzdC1kaXNjIG1sLTRcIj5cbiAgICAgICAgICAgIHtmYWlsZWRGaWxlcy5tYXAoKHsgZmlsZSwgZXJyb3IgfSwgaWR4KSA9PiAoXG4gICAgICAgICAgICAgIDxsaSBrZXk9e2lkeH0+e2ZpbGUubmFtZX06IHtlcnJvcn08L2xpPlxuICAgICAgICAgICAgKSl9XG4gICAgICAgICAgPC91bD5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJtdC0xIHB4LTIgcHktMSBiZy1yZWQtNjAwIHRleHQtd2hpdGUgcm91bmRlZCB0ZXh0LXhzIGhvdmVyOmJnLXJlZC03MDBcIlxuICAgICAgICAgICAgb25DbGljaz17cmV0cnlGYWlsZWR9XG4gICAgICAgICAgICBkaXNhYmxlZD17cmV0cnlpbmd9XG4gICAgICAgICAgPlxuICAgICAgICAgICAge3JldHJ5aW5nID8gJ1JldHJ5aW5nLi4uJyA6ICdSZXRyeSBGYWlsZWQgVXBsb2Fkcyd9XG4gICAgICAgICAgPC9idXR0b24+XG4gICAgICAgIDwvZGl2PlxuICAgICAgKX1cbiAgICA8L2Rpdj5cbiAgKTtcbn0gIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwic3VwYWJhc2UiLCJwcm9jZXNzSW1hZ2VUb1JhdGlvIiwiZmlsZSIsInRhcmdldFdpZHRoIiwidGFyZ2V0SGVpZ2h0IiwiYWRkQmFja2dyb3VuZCIsIlByb21pc2UiLCJyZXNvbHZlIiwiY2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3R4IiwiZ2V0Q29udGV4dCIsImltZyIsIkltYWdlIiwib25sb2FkIiwid2lkdGgiLCJoZWlnaHQiLCJncmFkaWVudCIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiYWRkQ29sb3JTdG9wIiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJpbWdBc3BlY3RSYXRpbyIsImNhbnZhc0FzcGVjdFJhdGlvIiwiZHJhd1dpZHRoIiwiZHJhd0hlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwiZHJhd0ltYWdlIiwidG9CbG9iIiwiYmxvYiIsInN1ZmZpeCIsIm5ld0ZpbGUiLCJGaWxlIiwibmFtZSIsInJlcGxhY2UiLCJ0eXBlIiwibGFzdE1vZGlmaWVkIiwiRGF0ZSIsIm5vdyIsIm9uZXJyb3IiLCJzcmMiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJoYXNQbmdUcmFuc3BhcmVuY3kiLCJpbmNsdWRlcyIsImNvbnNvbGUiLCJsb2ciLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJkYXRhIiwidHJhbnNwYXJlbnRQaXhlbHMiLCJ0b3RhbFBpeGVscyIsImxlbmd0aCIsImkiLCJoYXNUcmFuc3BhcmVuY3kiLCJlcnJvciIsIk1lZGlhVXBsb2FkZXIiLCJjYXJJZCIsIm9uVXBsb2FkZWQiLCJ1cGxvYWRpbmciLCJzZXRVcGxvYWRpbmciLCJwcm9ncmVzcyIsInNldFByb2dyZXNzIiwidG90YWxGaWxlcyIsInNldFRvdGFsRmlsZXMiLCJmYWlsZWRGaWxlcyIsInNldEZhaWxlZEZpbGVzIiwicmV0cnlpbmciLCJzZXRSZXRyeWluZyIsImhhbmRsZUZpbGVzIiwiZSIsImZpbGVzIiwiQXJyYXkiLCJmcm9tIiwidGFyZ2V0IiwiZmFpbGVkIiwiaWR4Iiwic3RhcnRzV2l0aCIsInZlcnNpb25zIiwia2luZCIsIm1ldGFkYXRhIiwidmVyc2lvbiIsInVwbG9hZFNpbmdsZVZlcnNpb24iLCJlcnIiLCJ3YXJuIiwiTWF0aCIsInJvdW5kIiwic2V0VGltZW91dCIsInZhbHVlIiwidXBsb2FkRmlsZSIsIm9yaWdpbmFsRmlsZSIsImZhaWxlZEFycmF5Iiwic2l6ZSIsImV4dCIsInNwbGl0IiwicG9wIiwiYmFzZUZpbGVOYW1lIiwibWV0YWRhdGFQcmVmaXgiLCJwYXRoIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsImNvdW50IiwicGhvdG9Db3VudCIsInNlbGVjdCIsImhlYWQiLCJlcSIsImlzRmlyc3RQaG90byIsInVwRXJyIiwic3RvcmFnZSIsInVwbG9hZCIsImNvbnRlbnRUeXBlIiwiY2FjaGVDb250cm9sIiwidXBzZXJ0IiwibWVzc2FnZSIsInB1c2giLCJwdWIiLCJnZXRQdWJsaWNVcmwiLCJ1cmwiLCJwdWJsaWNVcmwiLCJkYkVycm9yIiwiaW5zZXJ0IiwiY2FyX2lkIiwiaXNfcHJpbWFyeSIsInNvcnRfb3JkZXIiLCJyZXRyeUZhaWxlZCIsImZpbGVzVG9SZXRyeSIsIm1hcCIsImYiLCJkaXYiLCJjbGFzc05hbWUiLCJsYWJlbCIsImlucHV0IiwibXVsdGlwbGUiLCJhY2NlcHQiLCJvbkNoYW5nZSIsImRpc2FibGVkIiwic3R5bGUiLCJzcGFuIiwibWF4IiwidWwiLCJsaSIsImJ1dHRvbiIsIm9uQ2xpY2siXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/modules/uv-crm/components/MediaUploader.tsx\n"));

/***/ })

});